<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.4">
  <POU Name="FB_Binary_Search_Tree" Id="{d76a212e-55fb-4e7c-b3ab-4d299109146a}" SpecialFunc="None">
    <Declaration><![CDATA[// Dynamic Binary Search Tree
{attribute 'enable_dynamic_creation'}
{attribute 'no_assign'}
FUNCTION_BLOCK FB_Binary_Search_Tree EXTENDS FB_Collection IMPLEMENTS I_Binary_Search_Tree, I_Generic_Binary_Search_Tree
VAR
	Type_ 		: T_Type;
	pRoot 		: POINTER TO T_BST_Node;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Exceptions" Id="{3b396550-ffa1-45f4-b245-6e7d425c818a}" />
    <Folder Name="Private" Id="{156af957-ee3f-4ecd-b0e9-77a7877cb771}" />
    <Folder Name="Protected" Id="{b54132a2-37fd-451e-b12e-052f9b5a9535}" />
    <Property Name="_Type" Id="{b588d30b-25ed-4809-9db8-c278f0ed53a2}">
      <Declaration><![CDATA[// Gets the type of the data on the binary search tree
PROPERTY _Type : T_Type]]></Declaration>
      <Get Name="Get" Id="{4f1f4aeb-f42b-48ab-8c68-f9e94d3b9126}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_Type := THIS^.Type_;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{8b7456d6-70ba-4d34-98fd-131c8ec9f837}">
        <Declaration><![CDATA[PROTECTED 
VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.Type_ := _Type;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="Balance" Id="{29b0f06c-e4a0-463f-9a32-1233ad7cd7fa}">
      <Declaration><![CDATA[// Balances Binary Search Tree. Tree will normal auto balance every time its count is a multiple of 4
METHOD Balance
VAR
	pTemp 			 	 : POINTER TO T_BST_Node;
	pStack 				 : POINTER TO FB_Stack;
	pStack_List,
	pOrdered_List 		 : POINTER TO FB_List;
	pHelper_BST_Balancer : POINTER TO FB_Helper_BST_Balancer;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.pRoot = 0 THEN RETURN; END_IF

// Create helpers
pHelper_BST_Balancer := __NEW(FB_Helper_BST_Balancer);
pStack_List 		 := __NEW(FB_List);
pOrdered_List 		 := __NEW(FB_List);
pStack 				 := __NEW(FB_Stack);
pStack^(ipList := pStack_List^);

// Inorder traversal
pTemp := THIS^.pRoot;
WHILE (pTemp <> 0) OR (NOT pStack^._Is_Empty) DO
	IF pTemp <> 0 THEN pStack^.Push(pTemp); pTemp := pTemp^.pLeft; CONTINUE; END_IF
	pStack^.Pop(pTemp); 
	pOrdered_List^.Add_Back(pTemp);
	pTemp := pTemp^.pRight;
	END_WHILE

// Balance BST
pTemp := 0;
pHelper_BST_Balancer^(ipList := pOrdered_List^, nStart := 0, nEnd := pOrdered_List^._Count -1 , pNode => pTemp);
IF pTemp <> 0 THEN THIS^.pRoot := pTemp; END_IF

// Delete helpers
__DELETE(pHelper_BST_Balancer);
__DELETE(pStack_List);
__DELETE(pStack);
__DELETE(pOrdered_List);











(*
pCurrent := THIS^.pRoot;
WHILE pCurrent <> 0 DO 
	IF pCurrent^.pLeft = 0 THEN pCurrent := pCurrent^.pRight;  CONTINUE; END_IF
	
	pPrevious := pCurrent^.pLeft;
	WHILE (pPrevious^.pRight <> 0 ) AND (pPrevious^.pRight <> pCurrent) DO
		pPrevious := pPrevious^.pRight;
		IF pPrevious^.pRight = 0 THEN pPrevious^.pRight := pCurrent; pCurrent := pCurrent^.pLeft; CONTINUE; END_IF
		pPrevious^.pRight := 0;
		pCurrent := pCurrent^.pRight;
		END_WHILE
	
	END_WHILE
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="Balance_Ready" Id="{c43aec6d-484c-486d-b9ae-15cf7988a85d}" FolderPath="Protected\">
      <Declaration><![CDATA[// Checks if bst is ready to be balanced
METHOD PROTECTED Balance_Ready : BOOL
VAR
	nMod 		: T_Capacity;
END_VAR
VAR CONSTANT
	nMod_Const 	: T_Capacity := 4; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nMod := THIS^._Count MOD nMod_Const;
Balance_Ready := nMod = 0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Clear" Id="{4c3be9d7-5011-435f-b262-35042c884815}">
      <Declaration><![CDATA[(* Empties/Clears/Deletes every element on the collection *)
METHOD Clear
VAR
	pList 	: POINTER TO FB_List;
	pQueue 	: POINTER TO FB_Queue;
	pTemp 	: POINTER TO T_BST_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.pRoot = 0 THEN RETURN; END_IF
pList 	:= __NEW(FB_List);
pQueue 	:= __NEW(FB_Queue);
pQueue^(ipList := pList^);

pQueue^.Enqueue(THIS^.pRoot);
WHILE NOT pQueue^._Is_Empty DO
	pQueue^.Dequeue(pTemp);
	IF pTemp^.pLeft <> 0 THEN pQueue^.Enqueue(pTemp^.pLeft);END_IF
	IF pTemp^.pRight <> 0 THEN pQueue^.Enqueue(pTemp^.pRight);END_IF
	
	__DELETE(pTemp^.Data.pValue);
	__DELETE(pTemp);
	THIS^.DecrementCount();
	END_WHILE

THIS^.pRoot := 0;
__DELETE(pQueue);
__DELETE(pList);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Compare" Id="{87c20649-1544-4127-8637-101e28c4a0c5}" FolderPath="Protected\">
      <Declaration><![CDATA[// Compare A to B -> A<B = -1, A=B = 0, A>B = 1
METHOD PROTECTED Compare : DINT
VAR_INPUT
	A, B 	: T_Generic;
END_VAR
VAR
	nSizeA, 
	nSizeB 	: UDINT;
	n 		: DINT; 
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE A.TypeClass OF
	T_Type.TYPE_STRING:
		nSizeA := LEN2(A.pValue);
		IF (B.TypeClass = T_Type.TYPE_STRING) THEN nSizeB := LEN2(B.pValue)+1; JMP _COMPARE; END_IF
		nSizeB := 0;
			
	T_Type.TYPE_WSTRING:
		nSizeA := WLEN2(A.pValue);
		IF (B.TypeClass = T_Type.TYPE_WSTRING) THEN nSizeB := WLEN2(B.pValue)+1; JMP _COMPARE; END_IF
		nSizeB := 0;
ELSE
	Compare := MEMCMP(A.pValue, B.pValue, TO_UDINT(MIN(A.diSize, B.diSize)));
	RETURN;
END_CASE
_COMPARE:
Compare := MEMCMP(ADR(A), ADR(B), SIZEOF(UDINT));]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_exit" Id="{ff260ea6-fc8f-4e8a-ab92-dae70d701c25}">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
	bInCopyCode : BOOL; // if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.Clear();]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{272bb58c-858e-46fb-880f-53eaf077b94f}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains 	: BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode 	: BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	eType 			: T_Type;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^._Type := eType;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Find" Id="{0bf36cba-afa5-43ac-9141-3b8a596a4363}">
      <Declaration><![CDATA[(* Checks if data is contained in binary search tree *)
METHOD Find : I_Binary_Search_Tree
VAR_INPUT
	Data 		: ANY; 	// Data to remove
END_VAR
VAR_OUTPUT
	bFound 		: BOOL; // Indicates whether data was found. Found = TRUE, Not Found = FALSE
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Find := THIS^;
IF THIS^.InvalidTypeException(Data) THEN RETURN; END_IF
THIS^.Internal_Find(Data, bFound => bFound);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Find_Generic" Id="{a3bf0635-5def-4de1-8899-0a3400c79520}">
      <Declaration><![CDATA[// Checks if generic data is inside binary search tree
METHOD Find_Generic : I_Generic_Binary_Search_Tree
VAR_INPUT
	Data 		: T_Generic; 	// Generic Data to find
END_VAR
VAR_OUTPUT
	bFound 		: BOOL; // Indicates whether data was found. Found = TRUE, Not Found = FALSE
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Find_Generic := THIS^;
IF THIS^.InvalidTypeException(Data) THEN RETURN; END_IF
THIS^.Internal_Find(Data, bFound => bFound);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Insert" Id="{e5bb36ce-ecfc-4202-a7d2-60a8b27b5f43}">
      <Declaration><![CDATA[(* Insert data into binary search tree *)
METHOD Insert : I_Binary_Search_Tree
VAR_INPUT
	Data 		: ANY; // Data to insert
END_VAR
VAR_OUTPUT
	bSuccess 	: BOOL; // Indicates whether operation was successful. Success = TRUE, Failure = FALSE
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Insert := THIS^;
IF THIS^.InvalidTypeException(Data) THEN RETURN; END_IF
THIS^.Internal_Insert(Data, bSuccess => bSuccess);
IF (NOT THIS^.Balance_Ready()) OR (NOT bSuccess) THEN RETURN; END_IF
THIS^.Balance();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Insert_Generic" Id="{c1768710-62a0-4608-be2d-bf3d90509a02}">
      <Declaration><![CDATA[// Adds new generic item at into binary search tree.
// The binary seach tree will store a copy of the generic item so as to not modify the original value outside it's scope.
METHOD Insert_Generic : I_Generic_Binary_Search_Tree
VAR_INPUT
	Data 	: T_Generic; // Item to store
END_VAR
VAR_OUTPUT
	bSuccess 	: BOOL; // Indicates whether operation was successful. Success = TRUE, Failure = FALSE
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Insert_Generic := THIS^;
IF THIS^.InvalidTypeException(Data) THEN RETURN; END_IF
THIS^.Internal_Insert(Data, bSuccess => bSuccess);
IF (NOT THIS^.Balance_Ready()) OR (NOT bSuccess) THEN RETURN; END_IF
THIS^.Balance();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Internal_Find" Id="{155db1f9-5a96-47de-badc-e16bc58d3760}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Internal_Find
VAR_INPUT
	Data 		: T_Generic; 	// Generic Data to find
END_VAR
VAR_OUTPUT
	bFound 		: BOOL; // Indicates whether data was found. Found = TRUE, Not Found = FALSE
END_VAR
VAR
	nState 		: DINT;
	pCurrent 	: POINTER TO T_BST_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.pRoot = 0 THEN RETURN; END_IF

pCurrent := THIS^.pRoot;
WHILE pCurrent <> 0 DO
	nState := THIS^.Compare(Data, pCurrent^.Data);
	CASE nState OF
	-1: // Less than
		pCurrent := pCurrent^.pLeft;
	 0: // Equal
	 	bFound := TRUE; EXIT;
	 1: // Greater than
		pCurrent := pCurrent^.pRight;
	ELSE
		EXIT;
	END_CASE
	END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Internal_Insert" Id="{4ad01ce6-d540-465f-bf95-ecf1d2b72a9d}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Internal_Insert
VAR_INPUT
	Data 		: T_Generic; // Data to insert
END_VAR
VAR_OUTPUT
	bSuccess 	: BOOL; // Indicates whether operation was successful. Success = TRUE, Failure = FALSE
END_VAR
VAR
	nState 		: DINT;
	pNew_Node,
	pCurrent	: POINTER TO T_BST_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pNew_Node := THIS^.Malloc_Node(Data);

IF THIS^.pRoot = 0 THEN THIS^.pRoot := pNew_Node; bSuccess := TRUE; THIS^.IncrementCount(); RETURN; END_IF

pCurrent := THIS^.pRoot;
WHILE pCurrent <> 0 DO
	nState := THIS^.Compare(Data, pCurrent^.Data);
	CASE nState OF
	-1: // Less than
		IF pCurrent^.pLeft = 0 THEN pCurrent^.pLeft  := pNew_Node; bSuccess := TRUE; THIS^.IncrementCount(); RETURN; END_IF
		pCurrent  := pCurrent^.pLeft;
	 1: // Greater than
		IF pCurrent^.pRight = 0 THEN pCurrent^.pRight := pNew_Node; bSuccess := TRUE; THIS^.IncrementCount(); RETURN; END_IF
		pCurrent := pCurrent^.pRight;
	ELSE
		__DELETE(pNew_Node^.Data.pValue);
		__DELETE(pNew_Node);
		EXIT;
	END_CASE
	END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Internal_Remove" Id="{380e6db8-c4fc-49f8-bcd5-0006f3a1e0dc}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Internal_Remove : POINTER TO T_BST_Node
VAR_INPUT
	Data 		: T_Generic; // Data to remove
END_VAR
VAR_OUTPUT
	bSuccess 	: BOOL; 		// Indicates whether operation was successful. Success = TRUE, Failure = FALSE
END_VAR
VAR
	nState, nFirst 	: DINT;
	pCurrent, 
	pParent,
	pChild,
	pMin			: POINTER TO T_BST_Node;
	bInit 			: BOOL := TRUE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pCurrent := THIS^.pRoot;
WHILE pCurrent <> 0 DO
	nState := THIS^.Compare(Data, pCurrent^.Data);
	IF bInit THEN nFirst := nState; bInit := FALSE; END_IF
	CASE nState OF
	 0: // Equal
	 	EXIT;
	-1: // Less than
		pParent := pCurrent; pCurrent := pCurrent^.pLeft;
	 1: // Greater than   
	 	pParent := pCurrent; pCurrent := pCurrent^.pRight;
	END_CASE
	END_WHILE

IF pCurrent = 0 THEN RETURN; END_IF // Return if node not found

bSuccess := TRUE;
THIS^.DecrementCount();
 
IF (pCurrent^.pLeft = 0) OR (pCurrent^.pRight = 0) THEN
	
	pChild := SEL(pCurrent^.pLeft = 0, pCurrent^.pLeft, pCurrent^.pRight);
	
	IF pParent = 0 				 THEN THIS^.pRoot := pChild; __DELETE(pCurrent^.Data.pValue); __DELETE(pCurrent);	  RETURN; END_IF	
	IF pCurrent = pParent^.pLeft THEN pParent^.pLeft := pChild;  __DELETE(pCurrent^.Data.pValue); __DELETE(pCurrent); RETURN; END_IF
	pParent^.pRight := pChild;  __DELETE(pCurrent^.Data.pValue); __DELETE(pCurrent); RETURN;
	END_IF 
	
pParent := pCurrent;
pMin 	:= pCurrent^.pRight;
WHILE (pMin^.pLeft <> 0) DO pParent := pMin; pMin := pMin^.pLeft; END_WHILE

pCurrent^.Data := pMin^.Data;
IF pMin = pParent^.pLeft THEN pParent^.pLeft := pMin^.pRight; ELSE pParent^.pRight := pMin^.pRight; END_IF
	
__DELETE(pMin^.Data.pValue);
__DELETE(pMin);]]></ST>
      </Implementation>
    </Method>
    <Method Name="InvalidTypeException" Id="{3e205ce9-11ea-47f5-8d6c-66a24fbdea6a}" FolderPath="Exceptions\">
      <Declaration><![CDATA[METHOD PROTECTED InvalidTypeException : BOOL
VAR_INPUT
	Data	: T_Generic;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^._Type = T_Type.TYPE_ANY THEN RETURN; END_IF
InvalidTypeException := THIS^._Type <> Data.TypeClass;
THIS^.stError := F_Error(InvalidTypeException, GVL_CmpErrors.ERR_TYPE_MISMATCH, 'Invalid input type. Type class not equal to internal type');]]></ST>
      </Implementation>
    </Method>
    <Method Name="Is_Balanced" Id="{52b6e5e5-794c-4364-9d9c-82c414a309e6}" FolderPath="Protected\">
      <Declaration><![CDATA[// Checks if BST is Balanced
METHOD PROTECTED Is_Balanced : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="Malloc_Node" Id="{aa4153c7-45b5-4920-b59a-de3ed083f653}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Malloc_Node : POINTER TO T_BST_Node
VAR_INPUT
	Data 	: T_Generic;
END_VAR
VAR
	pTemp 	: POINTER TO T_BST_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pTemp 					:= __NEW(BYTE, SIZEOF(T_BST_Node));
pTemp^.Data.TypeClass 	:= Data.TypeClass;
pTemp^.Data.diSize 		:= Data.diSize;
pTemp^.Data.pValue 		:= __NEW(BYTE, TO_UDINT(Data.diSize));
MEMMOVE(pTemp^.Data.pValue, Data.pValue, TO_UDINT(Data.diSize));
Malloc_Node 			:= pTemp;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Remove" Id="{ff0a2aed-3f81-44b7-be00-f452815d7016}">
      <Declaration><![CDATA[(* Removes data from binary search tree *)
METHOD Remove : I_Binary_Search_Tree
VAR_INPUT
	Data : ANY; // Data to remove
END_VAR
VAR_OUTPUT
	bSuccess 	: BOOL; // Indicates whether operation was successful. Success = TRUE, Failure = FALSE
END_VAR
VAR
	nState 		: DINT;
	pCurrent, 
	pParent,
	pChild,
	pMin		: POINTER TO T_BST_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Remove := THIS^;
IF THIS^.InvalidTypeException(Data) THEN RETURN; END_IF
THIS^.Internal_Remove(Data, bSuccess => bSuccess);
IF (NOT THIS^.Balance_Ready()) OR (NOT bSuccess) THEN RETURN; END_IF
THIS^.Balance();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Traverse" Id="{12a87337-e1f3-4646-bdc9-0d5ad66d6985}">
      <Declaration><![CDATA[(* Traveses the binary search tree and appends into a collection *)
METHOD Traverse : I_Binary_Search_Tree
VAR_INPUT
	eMethod 		: T_BST_Traversal; // Method to traverse the binary search tree
	ipGeneric_List 	: I_Generic_List; 		// Collection to append data to.
END_VAR
VAR
	pList 		: POINTER TO FB_List;
	pQueue 		: POINTER TO FB_Queue;
	pStack 		: POINTER TO FB_Stack;
	pCurrent,
	pPrevious 	: POINTER TO T_BST_Node;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Traverse := THIS^;
IF THIS^.pRoot = 0 THEN RETURN; END_IF
IF ipGeneric_List = 0 THEN RETURN; END_IF

pList := __NEW(FB_List);

CASE eMethod OF
	T_BST_Traversal.Inorder:
		// In Order Traversal
		pStack := __NEW(FB_Stack);
		pStack^(ipList := pList^);
		pCurrent := THIS^.pRoot;
		WHILE (pCurrent <> 0) OR (NOT pStack^._Is_Empty) DO
			IF pCurrent <> 0 THEN pStack^.Push(pCurrent); pCurrent := pCurrent^.pLeft; CONTINUE; END_IF
			pStack^.Pop(pCurrent); 
			ipGeneric_List.Insert_Generic(pCurrent^.Data, ipGeneric_List._Count);
			pCurrent := pCurrent^.pRight;
			END_WHILE
		__DELETE(pStack);
		
	T_BST_Traversal.Postorder:
		// Post Order
		pStack := __NEW(FB_Stack);
		pStack^(ipList := pList^);
		pCurrent := THIS^.pRoot;
		
		WHILE (pCurrent <> 0) OR (NOT pStack^._Is_Empty) DO
			IF pCurrent <> 0 THEN pStack ^.Push(pCurrent); pCurrent := pCurrent^.pLeft; CONTINUE; END_IF
			pStack^.Top(pCurrent);
			IF (pCurrent^.pRight = 0) OR (pCurrent^.pRight = pPrevious) THEN 
				ipGeneric_List.Insert_Generic(pCurrent^.Data, ipGeneric_List._Count);
				pStack^.Pop_Void();
				pPrevious := pCurrent;
				pCurrent := 0;
				CONTINUE;
				END_IF
			pCurrent := pCurrent^.pRight;
			END_WHILE
		__DELETE(pStack);
		
	T_BST_Traversal.Preorder:
		// Preoder Traversal
		pStack := __NEW(FB_Stack);
		pStack^(ipList := pList^);
		pCurrent := THIS^.pRoot;
		pStack^.Push(pCurrent);
		WHILE NOT pStack^._Is_Empty DO
			pStack^.Pop(pCurrent);
			ipGeneric_List.Insert_Generic(pCurrent^.Data, ipGeneric_List._Count);
			IF pCurrent^.pRight <> 0 THEN pStack^.Push(pCurrent^.pRight); END_IF
			IF pCurrent^.pLeft  <> 0 THEN pStack^.Push(pCurrent^.pLeft); END_IF
			END_WHILE
		__DELETE(pStack);
		
	T_BST_Traversal.Level_Order:
		// Level Traversal
		pQueue 	:= __NEW(FB_Queue);
		pQueue^(ipList := pList^);
		pQueue^.Enqueue(THIS^.pRoot);
		WHILE NOT pQueue^._Is_Empty DO
			pQueue^.Dequeue(pCurrent);
			IF pCurrent^.pLeft <> 0 THEN pQueue^.Enqueue(pCurrent^.pLeft);END_IF
			IF pCurrent^.pRight <> 0 THEN pQueue^.Enqueue(pCurrent^.pRight);END_IF
			ipGeneric_List.Insert_Generic(pCurrent^.Data, ipGeneric_List._Count);
			END_WHILE
		__DELETE(pQueue);
END_CASE
__DELETE(pList);]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Binary_Search_Tree">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree._Type.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree._Type.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Balance">
      <LineId Id="167" Count="52" />
      <LineId Id="83" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Balance_Ready">
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Clear">
      <LineId Id="4" Count="0" />
      <LineId Id="40" Count="2" />
      <LineId Id="39" Count="0" />
      <LineId Id="11" Count="2" />
      <LineId Id="18" Count="2" />
      <LineId Id="31" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="14" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="43" Count="1" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Compare">
      <LineId Id="13" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="31" Count="1" />
      <LineId Id="20" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.FB_exit">
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.FB_init">
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Find">
      <LineId Id="9" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Find_Generic">
      <LineId Id="17" Count="1" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Insert">
      <LineId Id="13" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="74" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Insert_Generic">
      <LineId Id="16" Count="3" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Internal_Find">
      <LineId Id="6" Count="14" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Internal_Insert">
      <LineId Id="17" Count="14" />
      <LineId Id="46" Count="0" />
      <LineId Id="32" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Internal_Remove">
      <LineId Id="24" Count="17" />
      <LineId Id="73" Count="0" />
      <LineId Id="42" Count="2" />
      <LineId Id="48" Count="3" />
      <LineId Id="53" Count="4" />
      <LineId Id="62" Count="2" />
      <LineId Id="69" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.InvalidTypeException">
      <LineId Id="39" Count="1" />
      <LineId Id="29" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Is_Balanced">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Malloc_Node">
      <LineId Id="18" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="21" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Remove">
      <LineId Id="9" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="166" Count="0" />
      <LineId Id="168" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="149" Count="0" />
    </LineIds>
    <LineIds Name="FB_Binary_Search_Tree.Traverse">
      <LineId Id="106" Count="24" />
      <LineId Id="159" Count="0" />
      <LineId Id="161" Count="1" />
      <LineId Id="164" Count="0" />
      <LineId Id="166" Count="1" />
      <LineId Id="170" Count="2" />
      <LineId Id="169" Count="0" />
      <LineId Id="168" Count="0" />
      <LineId Id="173" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="132" Count="26" />
      <LineId Id="57" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>