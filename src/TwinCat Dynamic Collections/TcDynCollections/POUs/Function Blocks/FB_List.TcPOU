<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.4">
  <POU Name="FB_List" Id="{3608d5e7-b8e3-45a4-86d3-4cab6fa05db7}" SpecialFunc="None">
    <Declaration><![CDATA[// Dyanamic List that can store a collection of any types. Similiar to python lists.
{attribute 'enable_dynamic_creation'}
{attribute 'no_assign'}
FUNCTION_BLOCK FB_List EXTENDS FB_Collection IMPLEMENTS I_List, I_Generic_List
VAR
	pHead, pTail	: POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Exceptions" Id="{e7e4aa98-8a04-4870-bd0f-c64ea6bd7e2e}" />
    <Folder Name="Protected" Id="{b7c12b6c-2860-4236-884d-94b3020f74dd}" />
    <Property Name="_Is_Empty" Id="{83b747d5-0216-46e5-8331-e4ed76c2416e}">
      <Declaration><![CDATA[(* Checks of list is empty.*)
PROPERTY _Is_Empty : BOOL
]]></Declaration>
      <Get Name="Get" Id="{134c00de-bd88-4b9f-bf5c-b916f6f45111}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_Is_Empty := (THIS^._Count = 0);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Add_Back" Id="{056754d6-610e-4971-bc62-f05f5cbed254}">
      <Declaration><![CDATA[// Adds an item to the end of the list
METHOD Add_Back : I_List
VAR_INPUT
	Item 	: ANY; // Value to store in list
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR
	pTemp 	: POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Add_Back := THIS^;
IF THIS^._Is_Empty THEN THIS^.Add_Front(Item, bSuccess => bSuccess); RETURN; END_IF
pTemp := THIS^.Malloc_Node(Item);
THIS^.CopyValueTo(pTemp^.Data, Item);
THIS^.pTail := THIS^.pTail^.pNext := pTemp;
THIS^.IncrementCount();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Add_Front" Id="{2fd04b95-a74a-46ef-bd79-7cec09f4df87}">
      <Declaration><![CDATA[// Adds an item at the front of the list
METHOD Add_Front : I_List
VAR_INPUT
	Item 	: ANY; // Item to store in list
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR
	pTemp 	: POINTER TO ST_LIST_NODE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Add_Front := THIS^;
pTemp := THIS^.Malloc_Node(Item);
THIS^.CopyValueTo(pTemp^.Data, Item);
pTemp^.pNext := THIS^.pHead; THIS^.pHead := pTemp;
IF THIS^._Is_Empty THEN THIS^.pTail := THIS^.pHead; END_IF
THIS^.IncrementCount();
bSuccess := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Clear" Id="{bec97762-7b5e-424f-a529-90fba084e540}">
      <Declaration><![CDATA[(* Empties/Clears/Deletes every item in the list *)
METHOD Clear
VAR
	pTemp : POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pTemp := THIS^.pHead;
WHILE pTemp <> 0 DO
	pTemp := pTemp^.pNext; THIS^.Remove();
END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Contains" Id="{5490eaca-91a3-44f9-8fc8-9197bc0b23ae}">
      <Declaration><![CDATA[(* Checks if item is contained in list *)
METHOD Contains : BOOL
VAR_INPUT
	Item : ANY; // Item to find in list
END_VAR
VAR
	nIndex : DINT := -1;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.Find(Item, nIndex => nIndex, bSuccess => Contains);]]></ST>
      </Implementation>
    </Method>
    <Method Name="CopyValueTo" Id="{f1256ee2-117e-44ff-a280-45c5f906c678}" FolderPath="Protected\">
      <Declaration><![CDATA[// Copy data from source memory space to desination memory space
METHOD PROTECTED CopyValueTo
VAR_INPUT
	Dest, Src : __SYSTEM.AnyType;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMMOVE(Dest.pValue, Src.pValue, TO_UDINT(Dest.diSize));]]></ST>
      </Implementation>
    </Method>
    <Method Name="DecrementCount" Id="{7504ed87-0750-4486-af56-483d1f1ca92c}" FolderPath="Protected\">
      <Declaration><![CDATA[// Decrement list size by 1.
METHOD PROTECTED DecrementCount
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.nCount := THIS^.nCount - 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="EmptyListException" Id="{6c4ed729-c113-4386-a6c3-8db7e746795a}" FolderPath="Exceptions\">
      <Declaration><![CDATA[// Raises an expection if list is empty
METHOD PROTECTED EmptyListException : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^._Is_Empty THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 2936;
	stError.sSOURCE := 'List is empty';
ELSE
	This^.ClearException();
	END_IF
EmptyListException := stError.bSTATUS;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_exit" Id="{4c7cdb66-5714-4dc7-bb03-20df32d10b35}">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
	(* if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).*)
	bInCopyCode	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[This^.Clear();]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{511b1b72-4b6c-4f1c-b860-a838e892f1e2}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.Clear();
THIS^.pHead := THIS^.pTail := Tc3_Module.GVL.NULL;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Find" Id="{013937d5-c139-43db-b0da-bb96e2ed152e}">
      <Declaration><![CDATA[// Find the location of an item in list.
METHOD Find : I_List
VAR_INPUT
	Item 	 : ANY; // Item to find in list
END_VAR
VAR_OUTPUT
	nIndex	 : T_Capacity; //Location of item in list 
	bSuccess : BOOL;
END_VAR
VAR
	pTemp 	 : POINTER TO ST_LIST_NODE;
	i 		 : DINT;
	n 		 : DINT := -1;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Find := THIS^;
IF THIS^.EmptyListException() THEN nIndex := -1; RETURN; END_IF
pTemp := THIS^.pHead;
FOR i := 0 TO THIS^._Count-1 DO
	IF pTemp = 0 THEN EXIT; END_IF
	IF (pTemp^.Data.pValue = 0) 					THEN pTemp := pTemp^.pNext; CONTINUE; END_IF
	IF (Item.TypeClass <> pTemp^.Data.TypeClass) 	THEN pTemp := pTemp^.pNext; CONTINUE; END_IF
	IF (Item.pValue^ <> pTemp^.Data.pValue^) 		THEN pTemp := pTemp^.pNext; CONTINUE; END_IF
	
	CASE Item.TypeClass OF
		__SYSTEM.TYPE_CLASS.TYPE_STRING:
			IF LEN2(Item.pValue) <> LEN2(pTemp^.Data.pValue) THEN pTemp := pTemp^.pNext; CONTINUE; END_IF
			n := MEMCMP(Item.pValue, pTemp^.Data.pValue, LEN2(pTemp^.Data.pValue)+1);
				
		__SYSTEM.TYPE_CLASS.TYPE_WSTRING:
			IF WLEN2(Item.pValue) <> WLEN2(pTemp^.Data.pValue) THEN pTemp := pTemp^.pNext; CONTINUE; END_IF
			n := MEMCMP(Item.pValue, pTemp^.Data.pValue, (WLEN2(pTemp^.Data.pValue)*SIZEOF(WORD))+1);
	ELSE
		IF (Item.diSize <> pTemp^.Data.diSize) THEN pTemp := pTemp^.pNext; CONTINUE; END_IF	
		n := MEMCMP(Item.pValue, pTemp^.Data.pValue, TO_UDINT(Item.diSize));
	END_CASE
	IF n = 0 THEN nIndex := i; bSuccess := TRUE; RETURN; END_IF
	pTemp := pTemp^.pNext;
	END_FOR
nIndex := -1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Free_Node" Id="{fe77be5d-75df-45f5-82ef-b80273cbb525}" FolderPath="Protected\">
      <Declaration><![CDATA[// Deletes/frees node and it's value from memory
METHOD PROTECTED Free_Node
VAR_INPUT
	pNode : POINTER TO ST_LIST_NODE; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF pNode^.Data.pValue <> 0 THEN  __DELETE(pNode^.Data.pValue); END_IF
IF pNode <> 0 THEN __DELETE(pNode); END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get" Id="{f217126c-fbc8-4b16-bc91-0165668ad767}">
      <Declaration><![CDATA[// Gets item from list at specified location without removing it
METHOD Get : I_List
VAR_INPUT
	Return_Item 	: ANY;  // Variable to store returned item
	nIndex 			: T_Capacity; // Location of item
END_VAR
VAR_OUTPUT
	bSuccess 		: BOOL;
END_VAR
VAR
	pTemp : POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Get := THIS^;
IF THIS^.EmptyListException() THEN RETURN; END_IF
IF THIS^.OutOfBoundsException(nIndex) THEN RETURN; END_IF
IF nIndex = 0 THEN THIS^.Get_First(Return_Item, bSuccess => bSuccess); RETURN; END_IF
IF nIndex = THIS^._Count - 1 THEN THIS^.Get_Last(Return_Item, bSuccess => bSuccess); RETURN; END_IF
pTemp := Iterate(nIndex);
IF THIS^.TypeMismatchException(Return_Item, pTemp^.Data) THEN RETURN; END_IF
THIS^.CopyValueTo(Return_Item, pTemp^.Data);
bSuccess := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get_First" Id="{1bebd03d-aee6-473c-bace-1df90cf223c2}">
      <Declaration><![CDATA[// Gets item at the front of the list 
METHOD Get_First : I_List
VAR_INPUT
	Return_Item 	: ANY; // Variable to store returned item
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Get_First := THIS^;
IF THIS^.EmptyListException() THEN RETURN; END_IF
IF THIS^.TypeMismatchException(Return_Item, pHead^.Data) THEN RETURN; END_IF
THIS^.CopyValueTo(Return_Item, pHead^.Data);
bSuccess := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get_Generic" Id="{77fc5034-a533-428d-be68-e432cdd8fc67}">
      <Declaration><![CDATA[// Gets a value from a collection in it's generic form (* Use carefully as this contains the pointer of the action value in the collection. *)
METHOD Get_Generic : I_Generic_List
VAR_INPUT
	nIndex 		: T_Capacity; 			// Location of item
END_VAR
VAR_OUTPUT
	Return_Item : T_Generic;  	// Variable to store returned item
	bSuccess 	: BOOL;
END_VAR
VAR
	pTemp : POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Get_Generic := THIS^;
IF THIS^.EmptyListException() THEN RETURN; END_IF
IF THIS^.OutOfBoundsException(nIndex) THEN RETURN; END_IF

IF nIndex = THIS^._Count - 1 THEN pTemp := pTail; ELSE pTemp := THIS^.Iterate(nIndex); END_IF

IF THIS^.TypeMismatchException(Return_Item, pTemp^.Data) THEN RETURN; END_IF
Return_Item.diSize 		:= pTemp^.Data.diSize;
Return_Item.pValue 		:= pTemp^.Data.pValue;
Return_Item.TypeClass 	:= pTemp^.Data.TypeClass;
bSuccess := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get_Last" Id="{ced58a10-a606-40e3-aa00-f1704417ee24}">
      <Declaration><![CDATA[// Gets item at the back of the list 
METHOD Get_Last : I_List
VAR_INPUT
	Return_Item 	: ANY; // Variable to store returned item
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Get_Last := THIS^;
IF THIS^.EmptyListException() THEN RETURN; END_IF
IF THIS^.TypeMismatchException(Return_Item, pTail^.Data) THEN RETURN; END_IF
THIS^.CopyValueTo(Return_Item, pTail^.Data);
bSuccess := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get_Value_As_String" Id="{e01b4928-39b5-4c75-aed6-44a39cc9bded}">
      <Declaration><![CDATA[// Returns item as a string, if type to string conversion is supported
METHOD Get_Value_As_String : I_List
VAR_INPUT
	nIndex	: T_Capacity; // Location of item
END_VAR
VAR_OUTPUT
	sItem 	: T_MaxString; // Variable to store returned item
END_VAR
VAR
	pTemp : POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Get_Value_As_String := THIS^;
IF THIS^.EmptyListException() OR THIS^.OutOfBoundsException(nIndex) THEN sItem := 'ERR: List is Empty or index Out of Bounds'; RETURN; END_IF
pTemp := Iterate(nIndex);
sItem := pTemp^.Data.sValue;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetValueAsString" Id="{32c6d94d-c5d0-4b29-a13c-82fe6372151f}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED GetValueAsString : T_MaxString
VAR_INPUT
	 Value : __SYSTEM.AnyType;
END_VAR
VAR	
	pBool			: POINTER TO BOOL;
    pByte			: POINTER TO BYTE;
    pWord			: POINTER TO WORD;
    pDWord			: POINTER TO DWORD;
    pLWord			: POINTER TO LWORD;
    pSint			: POINTER TO SINT;
    pInt			: POINTER TO INT;
    pDint			: POINTER TO DINT;
    pLint			: POINTER TO LINT;
    pUSint			: POINTER TO USINT;
    pUInt			: POINTER TO UINT;
    pUDint			: POINTER TO UDINT;
    pULint			: POINTER TO ULINT;
    pReal			: POINTER TO REAL;
    pLReal			: POINTER TO LREAL;
    pString			: POINTER TO STRING(255);
    pWString		: POINTER TO WSTRING;
    pTime			: POINTER TO TIME;
    pDate			: POINTER TO DATE;
    pDate_And_Time	: POINTER TO DATE_AND_TIME;
    pTime_Of_Day	: POINTER TO TIME_OF_DAY;
    pPointer		: PVOID;
	pLTime 			: POINTER TO LTIME;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Value.pValue = 0 THEN GetValueAsString := 'NULL'; RETURN; END_IF;

CASE Value.TypeClass OF 
	__SYSTEM.TYPE_CLASS.TYPE_BOOL:
		pBool := Value.pValue;
		GetValueAsString := TO_STRING(pBool^);
		
    __SYSTEM.TYPE_CLASS.TYPE_BYTE:
		pByte := Value.pValue;
		GetValueAsString := TO_STRING(pByte^);
		
    __SYSTEM.TYPE_CLASS.TYPE_WORD:
		pWord := Value.pValue;
		GetValueAsString := TO_STRING(pWord^);
		
    __SYSTEM.TYPE_CLASS.TYPE_DWORD:
		pDWord := Value.pValue;
		GetValueAsString := TO_STRING(pDWord^);
		
    __SYSTEM.TYPE_CLASS.TYPE_LWORD:
		pLWord := Value.pValue;
		GetValueAsString := TO_STRING(pLWord^);
		
    __SYSTEM.TYPE_CLASS.TYPE_SINT:
		pSint := Value.pValue;
		GetValueAsString := TO_STRING(pSint^);
		
    __SYSTEM.TYPE_CLASS.TYPE_INT:
		pInt := Value.pValue;
		GetValueAsString := TO_STRING(pInt^);
		
    __SYSTEM.TYPE_CLASS.TYPE_DINT:
		pDint := Value.pValue;
		GetValueAsString := TO_STRING(pDint^);
		
    __SYSTEM.TYPE_CLASS.TYPE_LINT:
		pLint := Value.pValue;
		GetValueAsString := TO_STRING(pLint^);
		
    __SYSTEM.TYPE_CLASS.TYPE_USINT:
		pUSint := Value.pValue;
		GetValueAsString := TO_STRING(pUSint^);
		
    __SYSTEM.TYPE_CLASS.TYPE_UINT:
		pUInt := Value.pValue;
		GetValueAsString := TO_STRING(pUInt^);
		
    __SYSTEM.TYPE_CLASS.TYPE_UDINT:
		pUDint := Value.pValue;
		GetValueAsString := TO_STRING(pUDint^);
		
    __SYSTEM.TYPE_CLASS.TYPE_ULINT:
		pULint := Value.pValue;
		GetValueAsString := TO_STRING(pULint^);
		
   __SYSTEM.TYPE_CLASS.TYPE_REAL:
		pReal := Value.pValue;
		GetValueAsString := TO_STRING(pReal^);
		
    __SYSTEM.TYPE_CLASS.TYPE_LREAL:
		pLReal := Value.pValue;
		GetValueAsString := TO_STRING(pLReal^);
		
    __SYSTEM.TYPE_CLASS.TYPE_STRING:
		pString := Value.pValue;
		GetValueAsString := TO_STRING(pString^);
		
   __SYSTEM.TYPE_CLASS.TYPE_WSTRING:
		pWString := Value.pValue;
		GetValueAsString := TO_STRING(pWString^);
		
    __SYSTEM.TYPE_CLASS.TYPE_TIME:
		pTime := Value.pValue;
		GetValueAsString := TO_STRING(pTime^);
		
    __SYSTEM.TYPE_CLASS.TYPE_DATE:
		pDate := Value.pValue;
		GetValueAsString := TO_STRING(pDate^);
		
    __SYSTEM.TYPE_CLASS.TYPE_DATEANDTIME:
		pDate_And_Time := Value.pValue;
		GetValueAsString := TO_STRING(pDate_And_Time^);
		
    __SYSTEM.TYPE_CLASS.TYPE_TIMEOFDAY:
		pTime_Of_Day := Value.pValue;
		GetValueAsString := TO_STRING(pTime_Of_Day^);
	
	__SYSTEM.TYPE_CLASS.TYPE_POINTER:
		GetValueAsString := TO_STRING(Value.pValue);
		
	__SYSTEM.TYPE_CLASS.TYPE_LTIME:
		pLTime := Value.pValue;
		GetValueAsString := TO_STRING(pLTime^);
ELSE
	GetValueAsString := 'TYPE TO STRING CONVERSION NOT SUPPORTED BY THIS TYPE'; 
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="IncrementCount" Id="{f47efdd7-dddc-4489-9124-5a6d6231ae48}" FolderPath="Protected\">
      <Declaration><![CDATA[// Increments list size by 1
METHOD PROTECTED IncrementCount
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.nCount := THIS^.nCount + 1;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Insert" Id="{ada4077e-ff2c-4a09-ba98-35a178bde4fe}">
      <Declaration><![CDATA[// Adds new item to list at specified location, if index = 0, item will be added at the front, if index = count, item will be added at the back
METHOD Insert : I_List
VAR_INPUT
	Item 	: ANY;  // Item to store in list
	nIndex 	: T_Capacity; // Location of item
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR
	pPrevious 	: POINTER TO ST_LIST_NODE;
	pCurrent 	: POINTER TO ST_LIST_NODE;
	pTemp 		: POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Insert := THIS^;
IF nIndex = 0 THEN THIS^.Add_Front(Item, bSuccess => bSuccess); RETURN; END_IF
IF nIndex = THIS^._Count THEN THIS^.Add_Back(Item, bSuccess => bSuccess); RETURN; END_IF
IF THIS^.OutOfBoundsException(nIndex) THEN RETURN; END_IF

pTemp := THIS^.Malloc_Node(Item);
THIS^.CopyValueTo(pTemp^.Data, Item);

pPrevious := THIS^.Iterate(nIndex-1);
pCurrent := pPrevious^.pNext;
pPrevious^.pNext := pTemp;
pTemp^.pNext := pCurrent;

THIS^.IncrementCount();
bSuccess := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Insert_Generic" Id="{a354250d-c73a-45e6-90c3-e3c39cedc072}">
      <Declaration><![CDATA[// Adds new item to list at specified location using the generic form. If index = 0, item will be added at the front, if index = count, item will be added at the back
// To void race condition and memory leaks, a copy of the data/item in the generic form will be inserted. The original generic remains safe.
METHOD Insert_Generic : I_Generic_List
VAR_INPUT
	Item 	: T_Generic;  	// Item to store in list
	nIndex 	: T_Capacity; 			// Location of item
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR
	pPrevious, pCurrent, pTemp : POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Insert_Generic := THIS^;

pTemp := THIS^.Malloc_Node(Item);
THIS^.CopyValueTo(pTemp^.Data, Item);

// Add to front if nIndex = 0
IF nIndex = 0 THEN
	pTemp^.pNext := THIS^.pHead; THIS^.pHead := pTemp;
	IF THIS^._Is_Empty THEN THIS^.pTail := THIS^.pHead; END_IF
	THIS^.IncrementCount();
	bSuccess := TRUE;
	RETURN; 
	END_IF
	
// Add to back if nIndex = Count
IF nIndex = THIS^._Count THEN 
	THIS^.pTail := THIS^.pTail^.pNext := pTemp;
	THIS^.IncrementCount();
	bSuccess := TRUE;
	RETURN;
	END_IF

// Free temp node and return if the node is out of bounds
IF THIS^.OutOfBoundsException(nIndex) THEN THIS^.Free_Node(pTemp); RETURN; END_IF

// Insert value at specified position position if all checks are passed
pPrevious := THIS^.Iterate(nIndex-1);
pCurrent := pPrevious^.pNext;
pPrevious^.pNext := pTemp;
pTemp^.pNext := pCurrent;

THIS^.IncrementCount();
bSuccess := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Iterate" Id="{eba4f8b4-8859-4d38-978a-6ba6dc0efca0}" FolderPath="Protected\">
      <Declaration><![CDATA[// Returns pointer to node at specificied location;
METHOD PROTECTED Iterate : POINTER TO ST_LIST_NODE
VAR_INPUT
	nIndex : T_Capacity;
END_VAR
VAR_INST
	nState : BYTE;
	ii : T_Capacity;
	pT : POINTER TO ST_LIST_NODE;
END_VAR
VAR 
	i 		: DINT;
	pTemp 	: POINTER TO ST_LIST_NODE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.OutOfBoundsException(nIndex) THEN RETURN; END_IF
IF nIndex = 0 THEN Iterate := THIS^.pHead; RETURN; END_IF
//IF nIndex = THIS^._Count - 1 THEN Iterate := pTail; RETURN; END_IF {warning 'changes made here'}
pTemp := pHead;
FOR i := 1 TO nIndex DO pTemp := pTemp^.pNext; END_FOR
Iterate := pTemp;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Malloc_Node" Id="{2be6d349-c79d-45cd-88c5-8f4aba8a5d0f}" FolderPath="Protected\">
      <Declaration><![CDATA[// Allocate memory space for node and the value for it's data on the heap, returns pointer to node;
// WARNING!!! Always have a place to store the node pointer otherwise a memory leak will occur.
METHOD PROTECTED Malloc_Node : POINTER TO ST_LIST_NODE
VAR_INPUT
	Variable : __SYSTEM.AnyType;
END_VAR
VAR
	pTemp 	: POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pTemp 					:= __NEW(ST_LIST_NODE); // Allocate space in memory for a node.
pTemp^.Data.sValue 		:= THIS^.GetValueAsString(Variable);
pTemp^.Data.pValue 		:= __NEW(BYTE, TO_UDINT(Variable.diSize)); // Allocate space in memory to store data value.
pTemp^.Data.diSize 		:= Variable.diSize;
pTemp^.Data.TypeClass 	:= Variable.TypeClass;

Malloc_Node := pTemp;]]></ST>
      </Implementation>
    </Method>
    <Method Name="MemCmpErrExpection" Id="{8b653d35-5c25-44ee-9acb-cf180811d01f}" FolderPath="Exceptions\">
      <Declaration><![CDATA[// Compares memory sizes of 2 addresses. Returns TRUE  and raises error flag if theyre not same size.
METHOD PROTECTED MemCmpErrExpection : BOOL
VAR_INPUT
	pDestAddr,
	pSrcAddr 	: PVOID;
	nSize 		: UDINT;
END_VAR
VAR_INST
	nMemErr : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nMemErr := MEMCMP(pDestAddr, pSrcAddr, nSize);
IF nMemErr = -1 THEN 
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 4129;
	stError.sSOURCE := 'Incorrect parameter values. Destination address smaller than source address';
	
ELSIF nMemErr = 0 THEN THIS^.ClearException();
	
ELSIF nMemErr = 1 THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 4823;
	stError.sSOURCE := 'Incorrect parameter values. Destination address greater that source address';

ELSE
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 4564;
	stError.sSOURCE := 'Incorrect parameter values. Pointer to destination/source address is NULL or allocated address memory is NULL.';
	END_IF

MemCmpErrExpection := stError.bSTATUS;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="OutOfBoundsException" Id="{0e8cc9c9-3665-426c-ad93-2337aa0d7491}" FolderPath="Exceptions\">
      <Declaration><![CDATA[METHOD PROTECTED OutOfBoundsException : BOOL
VAR_INPUT
	nIndex : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (nIndex < 0) OR (nIndex >= THIS^._Count) THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 5374;
	stError.sSOURCE := 'Out of bounds. You tried to access data outside the range of this list.';
ELSE
	This^.ClearException();
	END_IF
OutOfBoundsException := stError.bSTATUS;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Remove" Id="{639458b4-b7c4-411d-8093-94e347b03982}">
      <Declaration><![CDATA[// Removes item at the front of the list and returns nothing
METHOD Remove : I_List
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR
	pTemp 	: POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Remove := THIS^;
IF THIS^._Is_Empty THEN RETURN; END_IF

pTemp := THIS^.pHead^.pNext;
THIS^.Free_Node(pHead);
THIS^.pHead := pTemp;

IF THIS^._Count = 1 THEN pTail := 0; END_IF

THIS^.DecrementCount();
bSuccess := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Remove_At" Id="{4211da5c-082b-418f-831f-636ce2ace62d}">
      <Declaration><![CDATA[// Remove item at specified location and return nothing
METHOD Remove_At : I_List
VAR_INPUT
	nIndex : T_Capacity; // Location of item
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR
	pTemp : ARRAY[1..2] OF POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Remove_At := THIS^;
IF THIS^.EmptyListException() OR THIS^.OutOfBoundsException(nIndex) THEN RETURN; END_IF
IF nIndex = 0 THEN THIS^.Remove(bSuccess => bSuccess); RETURN; END_IF
IF nIndex = THIS^._Count - 1 THEN THIS^.Remove_Last(bSuccess => bSuccess); RETURN; END_IF

pTemp[1] := THIS^.Iterate(nIndex-1);
pTemp[2] := pTemp[1]^.pNext^.pNext;
THIS^.Free_Node(pTemp[1]^.pNext);
pTemp[1]^.pNext := pTemp[2];

THIS^.DecrementCount();
bSuccess := TRUE;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Remove_Last" Id="{2f32c52b-f92b-439a-b828-14c100304a5e}">
      <Declaration><![CDATA[// Removes item at the back of the list and returns nothing
METHOD Remove_Last : I_List
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR
	pTemp : POINTER TO ST_LIST_NODE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Remove_Last := THIS^;
IF THIS^.EmptyListException() THEN RETURN; END_IF
IF THIS^._Count = 1 THEN THIS^.Remove(bSuccess => bSuccess); RETURN; END_IF
pTemp := THIS^.Iterate(THIS^._Count - 2);
THIS^.Free_Node(pTemp^.pNext);
pTail := pTemp;
THIS^.DecrementCount();
bSuccess := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Resize" Id="{18b979ce-2bc0-4748-9e2c-63a64e88a96e}">
      <Declaration><![CDATA[// Manually resize list. If list becomes smaller, items on higher locations will be deleted.
METHOD Resize : I_List
VAR_INPUT
	nSize : T_Capacity; // New size of list.
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR 
	Data 		: __SYSTEM.AnyType;
	nCount,i	: DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Resize := THIS^;
IF (nSize = THIS^._Count) OR (nSize < 0) THEN RETURN; END_IF 
IF nSize = 0 THEN THIS^.Clear(); bSuccess := TRUE; END_IF

nCount := THIS^._Count;

IF nSize < THIS^._Count THEN
	FOR i := 0 TO nCount - 1 DO
		THIS^.Remove_At(nCount - 1 - i, bSuccess => bSuccess);
		IF THIS^._Count = nSize THEN RETURN; END_IF
		END_FOR
	END_IF
	
IF nSize > THIS^._Count THEN
	FOR i := nCount TO nSize - 1 DO
		THIS^.Add_Back(Data, bSuccess => bSuccess);
		END_FOR
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reverse" Id="{163b036d-4e69-4b74-8841-8d30b26b2230}">
      <Declaration><![CDATA[// Reverses the order of items in the list
METHOD Reverse : I_List
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR
	pPrevious 	: POINTER TO ST_LIST_NODE;
	pCurrent 	: POINTER TO ST_LIST_NODE;
	pNext	 	: POINTER TO ST_LIST_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Reverse := THIS^;
IF THIS^._Count = 1 OR THIS^.EmptyListException() THEN RETURN; END_IF
pCurrent := THIS^.pTail := THIS^.pHead;
WHILE pCurrent <> 0 DO
	pNext := pCurrent^.pNext;
	pCurrent^.pNext := pPrevious;
	pPrevious := pCurrent;
	pCurrent := pNext;
	END_WHILE
THIS^.pHead := pPrevious;
bSuccess := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Set" Id="{5fd3c2d3-a7c8-432c-a1f7-89c4389d545b}">
      <Declaration><![CDATA[// Adds new item to list in the specified location without resizing list
METHOD Set : I_List
VAR_INPUT
	Item 	: ANY; 	// Item to store in list
	nIndex 	: T_Capacity; // Location of item
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR
VAR
	pTemp : POINTER TO ST_LIST_NODE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Set := THIS^;
IF THIS^.OutOfBoundsException(nIndex) THEN RETURN; END_IF

IF nIndex = THIS^._Count - 1 THEN 
	pTemp := THIS^.pTail;
ELSE 
	pTemp := Iterate(nIndex);
	END_IF

IF THIS^.TypeMismatchException(pTemp^.Data, Item) THEN RETURN; END_IF
THIS^.CopyValueTo(pTemp^.Data, Item);
bSuccess := TRUE;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetValue" Id="{bd1888ab-7ced-4793-a5b4-0802e782df58}" FolderPath="Protected\">
      <Declaration><![CDATA[(* Set value of __SYSTEM.Anytype variable *)
METHOD PROTECTED SetValue
VAR_INPUT
	Variable	: __SYSTEM.Anytype;
	Value 		: USINT; // Character/byte to set.
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMSET(Variable.pValue, Value, TO_UDINT(Variable.diSize));]]></ST>
      </Implementation>
    </Method>
    <Method Name="TypeMismatchException" Id="{32afae0e-e031-4fee-972f-846d7e93693d}" FolderPath="Exceptions\">
      <Declaration><![CDATA[METHOD TypeMismatchException : BOOL
VAR_INPUT
	Dest,
	Src 	: __SYSTEM.AnyType;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Dest.diSize <> Src.diSize THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 3172;
	stError.sSOURCE := 'Type mismatch. Byte sizes are not the same';
ELSIF Dest.TypeClass <> Src.TypeClass THEN
	stError.bSTATUS := TRUE;
	stError.nCODE 	:= 3172;
	stError.sSOURCE := 'Type mismatch. Type classes are not the same';
ELSE
	THIS^.ClearException();
END_IF
TypeMismatchException := stError.bSTATUS;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_List">
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_List._Is_Empty.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Add_Back">
      <LineId Id="219" Count="0" />
      <LineId Id="234" Count="0" />
      <LineId Id="220" Count="1" />
      <LineId Id="240" Count="0" />
      <LineId Id="226" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Add_Front">
      <LineId Id="35" Count="2" />
      <LineId Id="39" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="61" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Clear">
      <LineId Id="9" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Contains">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.CopyValueTo">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.DecrementCount">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.EmptyListException">
      <LineId Id="13" Count="5" />
      <LineId Id="8" Count="0" />
      <LineId Id="19" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.FB_exit">
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.FB_init">
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Find">
      <LineId Id="100" Count="23" />
      <LineId Id="38" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Free_Node">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Get">
      <LineId Id="68" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="70" Count="1" />
      <LineId Id="24" Count="0" />
      <LineId Id="95" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Get_First">
      <LineId Id="156" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="157" Count="1" />
      <LineId Id="175" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Get_Generic">
      <LineId Id="8" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="18" Count="1" />
      <LineId Id="21" Count="0" />
      <LineId Id="35" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Get_Last">
      <LineId Id="156" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="157" Count="1" />
      <LineId Id="186" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Get_Value_As_String">
      <LineId Id="38" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.GetValueAsString">
      <LineId Id="334" Count="1" />
      <LineId Id="210" Count="92" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.IncrementCount">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Insert">
      <LineId Id="108" Count="12" />
      <LineId Id="58" Count="0" />
      <LineId Id="134" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Insert_Generic">
      <LineId Id="8" Count="0" />
      <LineId Id="80" Count="8" />
      <LineId Id="108" Count="0" />
      <LineId Id="89" Count="6" />
      <LineId Id="109" Count="0" />
      <LineId Id="96" Count="11" />
      <LineId Id="46" Count="0" />
      <LineId Id="110" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Iterate">
      <LineId Id="5" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="24" Count="1" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Malloc_Node">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="22" Count="2" />
      <LineId Id="10" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.MemCmpErrExpection">
      <LineId Id="131" Count="19" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.OutOfBoundsException">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="4" />
      <LineId Id="6" Count="0" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Remove">
      <LineId Id="30" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Remove_At">
      <LineId Id="37" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="57" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Remove_Last">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="10" Count="3" />
      <LineId Id="22" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Resize">
      <LineId Id="7" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="43" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="27" Count="2" />
      <LineId Id="26" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Reverse">
      <LineId Id="21" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="8" Count="6" />
      <LineId Id="32" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.Set">
      <LineId Id="73" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="91" Count="4" />
      <LineId Id="76" Count="1" />
      <LineId Id="108" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="43" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.SetValue">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_List.TypeMismatchException">
      <LineId Id="5" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="11" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="24" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>