<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.4">
  <POU Name="FB_Tree_Map" Id="{d04e4e07-724f-4598-8f9a-33d5ba5477da}" SpecialFunc="None">
    <Declaration><![CDATA[// Binary search tree based map
{attribute 'enable_dynamic_creation'}
FUNCTION_BLOCK FB_Tree_Map EXTENDS FB_Collection IMPLEMENTS I_Tree_Map
VAR
	pRoot 			 		: POINTER TO ST_TREE_MAP_ENTRY_NODE;
	eTraversal 		 		: T_BST_Traversal;
	pKey_List,
	pValue_List 	 		: POINTER TO FB_List;
	pRead_Only_Key_List,
	pRead_Only_Value_List 	: POINTER TO FB_Read_Only_List;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Exceptions" Id="{2dd35cd4-663d-4a09-8352-206b264a1c4d}" />
    <Folder Name="Protected" Id="{9054c4e0-b82a-46c0-9987-ca89a924688a}" />
    <Property Name="_Keys" Id="{05b9efe6-1fc8-4e73-8a1e-df9e3b4eadc3}">
      <Declaration><![CDATA[// Gets a read-only list of the keys
PROPERTY _Keys : I_Read_Only_List]]></Declaration>
      <Get Name="Get" Id="{ab531493-2a62-406a-bbd5-bc1d2b19b71a}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF THIS^.pKey_List = 0 THEN THIS^.pKey_List := __NEW(FB_List); END_IF
IF THIS^.pRead_Only_Key_List = 0 THEN THIS^.pRead_Only_Key_List := __NEW(FB_Read_Only_List); END_IF

THIS^.pKey_List^.Clear();
THIS^.Internal_Traversal(FALSE,THIS^.pKey_List^);

THIS^.pRead_Only_Key_List^(ipList := THIS^.pKey_List^);
_Keys := THIS^.pRead_Only_Key_List^;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="_Traversal" Id="{75a68428-0dd6-4017-b208-d63c61e5caed}">
      <Declaration><![CDATA[// Get and set the order in which the property _Keys/Value should return values
PROPERTY _Traversal : T_BST_Traversal]]></Declaration>
      <Get Name="Get" Id="{5ea6d044-19d4-4f0c-a010-346210846ea5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_Traversal := THIS^.eTraversal;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{011cd406-2b2e-40f7-bf43-425d5c11b8a1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[THIS^.eTraversal := _Traversal;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="_Values" Id="{6dda8f07-95c7-45aa-877b-0c3c232d462a}">
      <Declaration><![CDATA[// Gets a read-only list of the values
PROPERTY _Values : I_Read_Only_List]]></Declaration>
      <Get Name="Get" Id="{fbdc7a98-5b0c-4291-8628-adb786f1eae9}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF THIS^.pValue_List = 0 THEN THIS^.pValue_List := __NEW(FB_List); END_IF
IF THIS^.pRead_Only_Value_List = 0 THEN THIS^.pRead_Only_Value_List := __NEW(FB_Read_Only_List); END_IF

THIS^.pValue_List^.Clear();
THIS^.Internal_Traversal(TRUE,THIS^.pValue_List^);

THIS^.pRead_Only_Value_List^(ipList := THIS^.pValue_List^);
_Values := THIS^.pRead_Only_Value_List^;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Balance" Id="{0c3c66a4-9900-4983-86cc-5560cbae8f4a}">
      <Declaration><![CDATA[// Balances Tree Map. Tree will normal auto balance every time its count is a multiple of 4
METHOD Balance
VAR
	pTemp 			 	 : POINTER TO ST_TREE_MAP_ENTRY_NODE;
	pStack 				 : POINTER TO FB_Stack;
	pStack_List,
	pOrdered_List 		 : POINTER TO FB_List;
	pHelper_BST_Balancer : POINTER TO FB_Helper_Tree_Map_Balancer;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.pRoot = 0 THEN RETURN; END_IF

// Create helpers
pHelper_BST_Balancer := __NEW(FB_Helper_Tree_Map_Balancer);
pStack_List 		 := __NEW(FB_List);
pOrdered_List 		 := __NEW(FB_List);
pStack 				 := __NEW(FB_Stack);
pStack^(ipList := pStack_List^);

// Inorder traversal
pTemp := THIS^.pRoot;
WHILE (pTemp <> 0) OR (NOT pStack^._Is_Empty) DO
	IF pTemp <> 0 THEN pStack^.Push(pTemp); pTemp := pTemp^.pLeft; CONTINUE; END_IF
	pStack^.Pop(pTemp); 
	pOrdered_List^.Add_Back(pTemp);
	pTemp := pTemp^.pRight;
	END_WHILE

// Balance BST
pTemp := 0;
pHelper_BST_Balancer^(ipList := pOrdered_List^, nStart := 0, nEnd := pOrdered_List^._Count -1 , pNode => pTemp);
IF pTemp <> 0 THEN THIS^.pRoot := pTemp; END_IF

pStack_List^.Clear();

// Delete helpers
__DELETE(pHelper_BST_Balancer);
__DELETE(pStack_List);
__DELETE(pStack);
__DELETE(pOrdered_List);











(*
pCurrent := THIS^.pRoot;
WHILE pCurrent <> 0 DO 
	IF pCurrent^.pLeft = 0 THEN pCurrent := pCurrent^.pRight;  CONTINUE; END_IF
	
	pPrevious := pCurrent^.pLeft;
	WHILE (pPrevious^.pRight <> 0 ) AND (pPrevious^.pRight <> pCurrent) DO
		pPrevious := pPrevious^.pRight;
		IF pPrevious^.pRight = 0 THEN pPrevious^.pRight := pCurrent; pCurrent := pCurrent^.pLeft; CONTINUE; END_IF
		pPrevious^.pRight := 0;
		pCurrent := pCurrent^.pRight;
		END_WHILE
	
	END_WHILE
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="Balance_Ready" Id="{0b66d670-7e90-49a5-9ff5-a1b1ea94b876}" FolderPath="Protected\">
      <Declaration><![CDATA[// Checks if bst is ready to be balanced
METHOD PROTECTED Balance_Ready : BOOL
VAR
	nMod 		: T_Capacity;
END_VAR
VAR CONSTANT
	nMod_Const 	: T_Capacity := 4; 
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nMod := THIS^._Count MOD nMod_Const;
Balance_Ready := nMod = 0;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Clear" Id="{62a33172-6766-4737-9561-503d8376ea6e}">
      <Declaration><![CDATA[(* Empties/Clears/Deletes every item in the collection*)
METHOD Clear
VAR
	pList 	: POINTER TO FB_List;
	pQueue 	: POINTER TO FB_Queue;
	pTemp 	: POINTER TO ST_TREE_MAP_ENTRY_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.pRoot = 0 THEN RETURN; END_IF
pList 	:= __NEW(FB_List);
pQueue 	:= __NEW(FB_Queue);
pQueue^(ipList := pList^);

pQueue^.Enqueue(THIS^.pRoot);
WHILE NOT pQueue^._Is_Empty DO
	pQueue^.Dequeue(pTemp);
	IF pTemp^.pLeft <> 0 THEN pQueue^.Enqueue(pTemp^.pLeft);END_IF
	IF pTemp^.pRight <> 0 THEN pQueue^.Enqueue(pTemp^.pRight);END_IF
	
	__DELETE(pTemp^.Key.pValue);
	__DELETE(pTemp^.Value.pValue);
	__DELETE(pTemp);
	THIS^.DecrementCount();
	END_WHILE

THIS^.pRoot := 0;
__DELETE(pQueue);
__DELETE(pList);

IF THIS^.pKey_List <> 0 THEN THIS^.pKey_List^.Clear(); END_IF
IF THIS^.pValue_List <> 0 THEN THIS^.pValue_List^.Clear(); END_IF

IF THIS^.pRead_Only_Key_List <> 0 THEN THIS^.pRead_Only_Key_List^.Clear(); END_IF
IF THIS^.pRead_Only_Value_List <> 0 THEN THIS^.pRead_Only_Value_List^.Clear(); END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Compare" Id="{142361e8-3edb-4831-ac80-5d058f7f92f7}" FolderPath="Protected\">
      <Declaration><![CDATA[// Compare A to B -> A<B = -1, A=B = 0, A>B = 1
METHOD PROTECTED Compare : DINT
VAR_INPUT
	A, B 	: T_Generic;
END_VAR
VAR
	nSizeA, 
	nSizeB 	: UDINT;
	n 		: DINT; 
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE A.TypeClass OF
	T_Type.TYPE_STRING:
		nSizeA := LEN2(A.pValue);

	T_Type.TYPE_WSTRING:
		nSizeA := WLEN2(A.pValue);
ELSE
	nSizeA := TO_UDINT(A.diSize);
END_CASE

CASE B.TypeClass OF
	T_Type.TYPE_STRING:
		nSizeB := LEN2(B.pValue);

	T_Type.TYPE_WSTRING:
		nSizeB := WLEN2(B.pValue);
ELSE
	nSizeB := TO_UDINT(B.diSize);
END_CASE

Compare := MEMCMP(A.pValue, B.pValue, MIN(nSizeA, nSizeB));]]></ST>
      </Implementation>
    </Method>
    <Method Name="Copy_Value" Id="{16756b5b-bff9-458c-b842-3576f947a693}" FolderPath="Protected\">
      <Declaration><![CDATA[// Copies A to B
METHOD PROTECTED Copy_Value : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_exit" Id="{e0f6f099-0e26-4928-9535-0efc52465ba1}">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
	bInCopyCode : BOOL; // if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.Clear();
IF THIS^.pKey_List 	 <> 0 	THEN __DELETE(THIS^.pKey_List); END_IF
IF THIS^.pValue_List <> 0 	THEN  __DELETE(THIS^.pValue_List); END_IF

IF THIS^.pRead_Only_Key_List   <> 0 THEN  __DELETE(THIS^.pRead_Only_Key_List); END_IF
IF THIS^.pRead_Only_Value_List <> 0 THEN  __DELETE(THIS^.pRead_Only_Value_List); END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Get" Id="{bad45752-27ea-4166-a1cd-ba6374331441}">
      <Declaration><![CDATA[// Gets the value associated with the specified key without removing the entry from the map
METHOD Get : I_Map
VAR_INPUT
	Key 			: ANY; // Key used to identify stored value
	Return_Value 	: ANY; // Variable to store requested value 
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Get := THIS^;
THIS^.Internal_Get(Key, Return_Value, bSuccess => bSuccess);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Insert" Id="{b0c89660-4c00-4582-a625-677656a7ac94}">
      <Declaration><![CDATA[// Insert an element with the provided key and value to the map
METHOD Insert : I_Map
VAR_INPUT
	Key 		: ANY; // Key used to identify stored value
	Value 		: ANY; // Value to store in map with key
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Insert := THIS^;
THIS^.Internal_Insert(Key, Value, bSuccess => bSuccess);
IF NOT THIS^.Balance_Ready() THEN RETURN; END_IF
THIS^.Balance();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Internal_Get" Id="{9e690a40-4fde-4fb5-928d-facf50f257ec}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Internal_Get
VAR_INPUT
	Key, 
	Return_Value 		: T_Generic; // Data to insert
END_VAR
VAR_OUTPUT
	bSuccess 			: BOOL; // Indicates whether operation was successful. Success = TRUE, Failure = FALSE
END_VAR
VAR
	nState 				: DINT;
	pNew_Node,
	pCurrent			: POINTER TO ST_TREE_MAP_ENTRY_NODE;
	nReturn_Value_Size,
	nValue_Size 		: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.pRoot = 0 THEN RETURN; END_IF

pCurrent := THIS^.pRoot;
WHILE pCurrent <> 0 DO
	nState := THIS^.Compare(Key, pCurrent^.Key);
	CASE nState OF
	-1: // Less than
		pCurrent := pCurrent^.pLeft;
	 1: // Greater than
		pCurrent := pCurrent^.pRight;
	 0: // Equal
	 	IF Return_Value.TypeClass <> pCurrent^.Value.TypeClass THEN RETURN; END_IF
		CASE Return_Value.TypeClass OF
			T_Type.TYPE_STRING: 
				nReturn_Value_Size 	:= LEN2(Return_Value.pValue)+1;
				nValue_Size 		:= LEN2(pCurrent^.Value.pValue)+1;
			T_Type.TYPE_WSTRING:
				nReturn_Value_Size 	:= (WLEN2(Return_Value.pValue)*SIZEOF(WORD))+SIZEOF(WORD);
				nValue_Size 		:= (WLEN2(pCurrent^.Value.pValue)*SIZEOF(WORD))+SIZEOF(WORD);
		ELSE
			IF Return_Value.diSize <> pCurrent^.Value.diSize THEN RETURN; END_IF
			nReturn_Value_Size 		:= TO_UDINT(Return_Value.diSize);
			nValue_Size 			:= TO_UDINT(pCurrent^.Value.diSize);
		END_CASE
		MEMMOVE(Return_Value.pValue, pCurrent^.Value.pValue, nValue_Size);
		bSuccess := TRUE;
	 	EXIT; 
	ELSE
		EXIT;
	END_CASE
	END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Internal_Insert" Id="{561fbdfe-f9a2-4437-8fe4-881eac8596c0}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Internal_Insert
VAR_INPUT
	Key, Value 		: T_Generic; // Data to insert
END_VAR
VAR_OUTPUT
	bSuccess 	: BOOL; // Indicates whether operation was successful. Success = TRUE, Failure = FALSE
END_VAR
VAR
	nState 		: DINT;
	pNew_Node,
	pCurrent	: POINTER TO ST_TREE_MAP_ENTRY_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pNew_Node := THIS^.Malloc_Node(Key, Value);

IF THIS^.pRoot = 0 THEN THIS^.pRoot := pNew_Node; bSuccess := TRUE; THIS^.IncrementCount(); RETURN; END_IF

pCurrent := THIS^.pRoot;
WHILE pCurrent <> 0 DO
	nState := THIS^.Compare(Key, pCurrent^.Key);
	CASE nState OF
	-1: // Less than
		IF pCurrent^.pLeft = 0 THEN pCurrent^.pLeft  := pNew_Node; bSuccess := TRUE; THIS^.IncrementCount(); RETURN; END_IF
		pCurrent  := pCurrent^.pLeft;
	 1: // Greater than
		IF pCurrent^.pRight = 0 THEN pCurrent^.pRight := pNew_Node; bSuccess := TRUE; THIS^.IncrementCount(); RETURN; END_IF
		pCurrent := pCurrent^.pRight;
	ELSE
		__DELETE(pNew_Node^.Key.pValue);
		__DELETE(pNew_Node^.Value.pValue);
		__DELETE(pNew_Node);
		EXIT;
	END_CASE
	END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Internal_Remove" Id="{03411a27-22ed-4776-ae77-eb82719c4365}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Internal_Remove : POINTER TO T_BST_Node
VAR_INPUT
	Key				: T_Generic; 	// Data to remove
END_VAR
VAR_OUTPUT
	bSuccess 		: BOOL; 		// Indicates whether operation was successful. Success = TRUE, Failure = FALSE
END_VAR
VAR
	nState, nFirst 	: DINT;
	pCurrent, 
	pParent,
	pChild,
	pMin			: POINTER TO ST_TREE_MAP_ENTRY_NODE;
	bInit 			: BOOL := TRUE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pCurrent := THIS^.pRoot;
WHILE pCurrent <> 0 DO
	nState := THIS^.Compare(Key, pCurrent^.Key);
	IF bInit THEN nFirst := nState; bInit := FALSE; END_IF
	CASE nState OF
	 0: // Equal
	 	EXIT;
	-1: // Less than
		pParent := pCurrent; pCurrent := pCurrent^.pLeft;
	 1: // Greater than   
	 	pParent := pCurrent; pCurrent := pCurrent^.pRight;
	END_CASE
	END_WHILE

IF pCurrent = 0 THEN RETURN; END_IF // Return if node not found

bSuccess := TRUE;
THIS^.DecrementCount();
 
IF (pCurrent^.pLeft = 0) OR (pCurrent^.pRight = 0) THEN
	
	pChild := SEL(pCurrent^.pLeft = 0, pCurrent^.pLeft, pCurrent^.pRight);
	
	IF pParent = 0 THEN 
		THIS^.pRoot := pChild;
	ELSE 
		IF pCurrent = pParent^.pLeft THEN pParent^.pLeft := pChild; ELSE pParent^.pRight := pChild; END_IF
		END_IF
		
	__DELETE(pCurrent^.Key.pValue);
	__DELETE(pCurrent^.Value.pValue);
 	__DELETE(pCurrent);
	RETURN;
	END_IF
	
pParent := pCurrent;
pMin 	:= pCurrent^.pRight;
WHILE (pMin^.pLeft <> 0) DO
	pParent := pMin;
	pMin 	:= pMin^.pLeft;
	END_WHILE

pCurrent^.Key := pMin^.Key;
pCurrent^.Value := pMin^.Value;
IF pMin = pParent^.pLeft THEN pParent^.pLeft := pMin^.pRight; ELSE pParent^.pRight := pMin^.pRight; END_IF

__DELETE(pMin^.Key.pValue);
__DELETE(pMin^.Value.pValue);
__DELETE(pMin);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Internal_Traversal" Id="{76312b7f-892c-4b70-be71-c475a98f2d3f}" FolderPath="Protected\">
      <Declaration><![CDATA[(* Traveses the binary search tree and appends into a collection *)
METHOD PROTECTED Internal_Traversal
VAR_INPUT
	bValue 			: BOOL;				 // By if TRUE ipGeneric_List if populated with values else it's populated with keys 
	ipGeneric_List 	: I_Generic_List; // Collection to append data to.
END_VAR
VAR
	pList 		: POINTER TO FB_List;
	pQueue 		: POINTER TO FB_Queue;
	pStack 		: POINTER TO FB_Stack;
	pCurrent,
	pPrevious 	: POINTER TO ST_TREE_MAP_ENTRY_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF THIS^.pRoot = 0 THEN RETURN; END_IF
IF ipGeneric_List = 0 THEN RETURN; END_IF

pList := __NEW(FB_List);

CASE THIS^._Traversal OF
	T_BST_Traversal.Inorder:
		// In Order Traversal
		pStack := __NEW(FB_Stack);
		pStack^(ipList := pList^);
		pCurrent := THIS^.pRoot;
		WHILE (pCurrent <> 0) OR (NOT pStack^._Is_Empty) DO
			IF pCurrent <> 0 THEN pStack^.Push(pCurrent); pCurrent := pCurrent^.pLeft; CONTINUE; END_IF
			pStack^.Pop(pCurrent); 
			
			IF bValue THEN
				ipGeneric_List.Insert_Generic(pCurrent^.Value, ipGeneric_List._Count);
			ELSE
				ipGeneric_List.Insert_Generic(pCurrent^.Key, ipGeneric_List._Count);
				END_IF
			
			pCurrent := pCurrent^.pRight;
			END_WHILE
		__DELETE(pStack);
		
	T_BST_Traversal.Postorder:
		// Post Order
		pStack := __NEW(FB_Stack);
		pStack^(ipList := pList^);
		pCurrent := THIS^.pRoot;
		
		WHILE (pCurrent <> 0) OR (NOT pStack^._Is_Empty) DO
			IF pCurrent <> 0 THEN pStack ^.Push(pCurrent); pCurrent := pCurrent^.pLeft; CONTINUE; END_IF
			pStack^.Top(pCurrent);
			IF (pCurrent^.pRight = 0) OR (pCurrent^.pRight = pPrevious) THEN
				
				IF bValue THEN
					ipGeneric_List.Insert_Generic(pCurrent^.Value, ipGeneric_List._Count);
				ELSE
					ipGeneric_List.Insert_Generic(pCurrent^.Key, ipGeneric_List._Count);
					END_IF
				
				pStack^.Pop_Void();
				pPrevious := pCurrent;
				pCurrent := 0;
				CONTINUE;
				END_IF
			pCurrent := pCurrent^.pRight;
			END_WHILE
		__DELETE(pStack);
		
	T_BST_Traversal.Preorder:
		// Preoder Traversal
		pStack := __NEW(FB_Stack);
		pStack^(ipList := pList^);
		pCurrent := THIS^.pRoot;
		pStack^.Push(pCurrent);
		WHILE NOT pStack^._Is_Empty DO
			pStack^.Pop(pCurrent);
			
			IF bValue THEN
				ipGeneric_List.Insert_Generic(pCurrent^.Value, ipGeneric_List._Count);
			ELSE
				ipGeneric_List.Insert_Generic(pCurrent^.Key, ipGeneric_List._Count);
				END_IF
			
			IF pCurrent^.pRight <> 0 THEN pStack^.Push(pCurrent^.pRight); END_IF
			IF pCurrent^.pLeft  <> 0 THEN pStack^.Push(pCurrent^.pLeft); END_IF
			END_WHILE
		__DELETE(pStack);
		
	T_BST_Traversal.Level_Order:
		// Level Traversal
		pQueue 	:= __NEW(FB_Queue);
		pQueue^(ipList := pList^);
		pQueue^.Enqueue(THIS^.pRoot);
		WHILE NOT pQueue^._Is_Empty DO
			pQueue^.Dequeue(pCurrent);
			IF pCurrent^.pLeft <> 0 THEN pQueue^.Enqueue(pCurrent^.pLeft);END_IF
			IF pCurrent^.pRight <> 0 THEN pQueue^.Enqueue(pCurrent^.pRight);END_IF
			
			IF bValue THEN
				ipGeneric_List.Insert_Generic(pCurrent^.Value, ipGeneric_List._Count);
			ELSE
				ipGeneric_List.Insert_Generic(pCurrent^.Key, ipGeneric_List._Count);
				END_IF
				
			END_WHILE
		__DELETE(pQueue);
END_CASE
__DELETE(pList);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Internal_Update" Id="{0fbab4a5-2072-4b22-8ce3-0e1f4622f3c1}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Internal_Update
VAR_INPUT
	Key, Value 		: T_Generic; // Data to insert
END_VAR
VAR_OUTPUT
	bSuccess 	: BOOL; // Indicates whether operation was successful. Success = TRUE, Failure = FALSE
END_VAR
VAR
	nState 		: DINT;
	pNew_Node,
	pCurrent	: POINTER TO ST_TREE_MAP_ENTRY_NODE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pNew_Node := THIS^.Malloc_Node(Key, Value);
IF THIS^.pRoot = 0 THEN RETURN; END_IF

pCurrent := THIS^.pRoot;
WHILE pCurrent <> 0 DO
	nState := THIS^.Compare(Key, pCurrent^.Key);
	CASE nState OF
	-1: // Less than
		pCurrent := pCurrent^.pLeft;
	 1: // Greater than
		pCurrent := pCurrent^.pRight;
	 0: // Equal
	 	__DELETE(pCurrent^.Value.pValue);
		pCurrent^.Value := THIS^.Malloc_Value(Value);
		bSuccess := TRUE;
	 	EXIT; 
	ELSE
		EXIT;
	END_CASE
	END_WHILE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Malloc_Node" Id="{75cc05d3-25b0-46e4-a951-6ca2e7af64fa}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Malloc_Node : POINTER TO ST_TREE_MAP_ENTRY_NODE
VAR_INPUT
	Key, Value : T_Generic;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Malloc_Node 		:= __NEW(ST_TREE_MAP_ENTRY_NODE);
Malloc_Node^.Key 	:= THIS^.Malloc_Value(Key);
Malloc_Node^.Value 	:= THIS^.Malloc_Value(Value);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Malloc_Value" Id="{b6984ca3-a6b6-4723-a342-a5b5efffeb6a}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED Malloc_Value : T_Generic
VAR_INPUT
	Data : T_Generic;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Malloc Value
Malloc_Value.TypeClass 	:= Data.TypeClass;
Malloc_Value.diSize 	:= Data.diSize;
Malloc_Value.pValue 	:= __NEW(BYTE, TO_UDINT(Data.diSize));
MEMMOVE(Malloc_Value.pValue, Data.pValue, TO_UDINT(Data.diSize));]]></ST>
      </Implementation>
    </Method>
    <Method Name="Remove" Id="{233da212-de4e-4cde-9501-1e087b269fae}">
      <Declaration><![CDATA[// Removes value with the specified key from the map
METHOD Remove : I_Map
VAR_INPUT
	Key : ANY; // Key used to identify stored value
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Remove := THIS^;
THIS^.Internal_Remove(Key, bSuccess => bSuccess);
IF NOT THIS^.Balance_Ready() THEN RETURN; END_IF
THIS^.Balance();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Update" Id="{67e8db44-3009-49e2-a905-83472f08112b}">
      <Declaration><![CDATA[// Updates the value an element with the provided key and value in the map
METHOD Update : I_Map
VAR_INPUT
	Key 	: ANY; // Key used to identify stored value
	Value 	: ANY; // Value to store in map with key
END_VAR
VAR_OUTPUT
	bSuccess : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Update := THIS^;
THIS^.Internal_Update(Key, Value, bSuccess => bSuccess);]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Tree_Map">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map._Keys.Get">
      <LineId Id="2" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="3" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map._Traversal.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map._Traversal.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map._Values.Get">
      <LineId Id="13" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Balance">
      <LineId Id="167" Count="21" />
      <LineId Id="220" Count="1" />
      <LineId Id="189" Count="30" />
      <LineId Id="83" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Balance_Ready">
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="22" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Clear">
      <LineId Id="24" Count="11" />
      <LineId Id="42" Count="0" />
      <LineId Id="36" Count="5" />
      <LineId Id="8" Count="0" />
      <LineId Id="44" Count="1" />
      <LineId Id="43" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="46" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Compare">
      <LineId Id="65" Count="19" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Copy_Value">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.FB_exit">
      <LineId Id="13" Count="0" />
      <LineId Id="19" Count="3" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Get">
      <LineId Id="8" Count="0" />
      <LineId Id="92" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Insert">
      <LineId Id="8" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="80" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Internal_Get">
      <LineId Id="19" Count="1" />
      <LineId Id="57" Count="5" />
      <LineId Id="65" Count="1" />
      <LineId Id="70" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="95" Count="1" />
      <LineId Id="93" Count="0" />
      <LineId Id="97" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="102" Count="1" />
      <LineId Id="94" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="67" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Internal_Insert">
      <LineId Id="17" Count="14" />
      <LineId Id="46" Count="1" />
      <LineId Id="32" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Internal_Remove">
      <LineId Id="24" Count="17" />
      <LineId Id="73" Count="0" />
      <LineId Id="42" Count="2" />
      <LineId Id="48" Count="1" />
      <LineId Id="98" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="55" Count="2" />
      <LineId Id="59" Count="4" />
      <LineId Id="89" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="102" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Internal_Traversal">
      <LineId Id="107" Count="5" />
      <LineId Id="204" Count="7" />
      <LineId Id="271" Count="0" />
      <LineId Id="284" Count="3" />
      <LineId Id="212" Count="0" />
      <LineId Id="270" Count="0" />
      <LineId Id="213" Count="13" />
      <LineId Id="268" Count="0" />
      <LineId Id="280" Count="3" />
      <LineId Id="227" Count="0" />
      <LineId Id="269" Count="0" />
      <LineId Id="228" Count="16" />
      <LineId Id="267" Count="0" />
      <LineId Id="276" Count="3" />
      <LineId Id="245" Count="0" />
      <LineId Id="266" Count="0" />
      <LineId Id="246" Count="13" />
      <LineId Id="264" Count="0" />
      <LineId Id="272" Count="0" />
      <LineId Id="260" Count="0" />
      <LineId Id="273" Count="0" />
      <LineId Id="265" Count="0" />
      <LineId Id="274" Count="1" />
      <LineId Id="261" Count="2" />
      <LineId Id="57" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Internal_Update">
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="57" Count="5" />
      <LineId Id="65" Count="1" />
      <LineId Id="70" Count="0" />
      <LineId Id="73" Count="2" />
      <LineId Id="72" Count="0" />
      <LineId Id="67" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Malloc_Node">
      <LineId Id="38" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Malloc_Value">
      <LineId Id="7" Count="3" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Remove">
      <LineId Id="8" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="26" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tree_Map.Update">
      <LineId Id="8" Count="0" />
      <LineId Id="35" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>